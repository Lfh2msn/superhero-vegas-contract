@compiler >= 6

include "String.aes"
include "List.aes"

payable contract VegasMarketContact =


    datatype event =
        AddMarket(address, hash, int)
        | SubmitAnswer(address, hash, int)
        | ReceiveReward(address, int,int)
        | ContractBalance(int)
        | Swap(address, int)

    /**
     * Vegas的合约状态
     * - markets: 存放所有用户发起的投注信息
     * - user_markets_record: 已参与过投注的历史记录
     * - oracle_market:小型预言机，超管提供的数据
     * - oracle_market_count:某个预测已经投票过的次数
     * - oracle_market_record:管理员投票后的历史记录
     * - owner: 合约归属者
     * - aggregator_user: 合约的管理账户
     * - orcele_trigger_count:触发等待结果状态更新为已结束状态的标记
     */
    record state = {
        //预测的内容，哪个用户预测的id的预测内容(用户, map(预测id, 预测细节))
        markets              : map(address, map(hash, market)),
        //用户投票记录，那个账户发布的哪个预测的那个用户投票的第几个结果
        user_markets_record  : map(address, map(hash, map(address,int))),
        //某个预测的结果合集
        oracle_market        : map(hash, list(int)),
         //已经预测的次数
        oracle_market_count  : map(hash, int),
        //管理员投票的记录，用于后期审查
        oracle_market_record : map(hash, map(address, int)),
        //合约归属者
        owner                : address,
        //管理员账户
        aggregator_user      : map(address, string),
        //触发预测完成的次数
        orcele_trigger_count : int}


    //获取最多投票的结果
    entrypoint most_of((x :: xs) : list('a )) : 'a  =
        most_of_(x, {[x] = 1}, xs)

    function most_of_(most : 'a, counts : map('a, int), xs : list('a)) =
        switch(xs)
            [] => (most)
            (x :: xs) =>
                let counts' = counts{ [x = 0] @ n = n + 1 }
                if (counts'[x] >= counts'[most])
                    most_of_(x, counts', xs)
                else
                    most_of_(most, counts', xs)

    /**
     * 预测详情信息
     * - content: 预测的内容
     * - source_url: 预测的结果查询url地址
     * - answers: 预测的答案选项
     * - create_height: 发布预测时候的创建的高度
     * - create_time: 创建预测的时间
     * - min_amount: 最小的投注金额
     * - total_amount: 当前预测已经投注的总金额
     * - result: 该预测的答案是什么
     * - progress: 当前预测的进度（0）进行中的状态，（1）等待结果状态，（2）已结束的状态 (999)作废状态，只有合约合约归属者可用
     * - market_type: 当前预测的类型（0）聚合器模式，（1）私有模式
     */
    record market = {
        market_id     : hash,
        owner         : address,
        content       : string,
        source_url    : string,
        answers       : list(answer),
        create_height : int,
        create_time   : int,
        over_time     : int,
        min_amount    : int,
        total_amount  : int,
        result        : int,
        progress      : int,
        market_type   : int}


    /**
     * 预测的答案
     * - content: 预测答案的内容
     * - accounts: 已经投注的用户
     */
    record answer = {
        content  : string,
        count    : int}


    stateful entrypoint
        init : () => state
        init () =
            let owner              = Call.caller
            { markets              = {},
              oracle_market        = {},
              oracle_market_count  = {},
              oracle_market_record = {},
              user_markets_record  = {},
              owner                = Call.caller,
              aggregator_user      = {},
              orcele_trigger_count = 1}




    /**
     * 发布一个预测，只有聚合器用户才可以发布 status=(0) 的预测
     * - content: 主题
     * - source_url: 获取结果的地址
     * - min_amount: 最小支付数量
     * - over_time: 结束时间戳，从当前时间开始相加
     * - answers: 答案结果
     */
    stateful entrypoint
        add_market : (string,string,int,int,list(answer)) => market
        add_market (content,source_url,min_amount,over_time,answers) =
            //最低结束时间也要大于当前时间1天和小于30天
            // require(over_time >= 86400000, "OVER TIME MORE THAN 1 DAY IS REQUIRED")
            // require(over_time =< 86400000 * 30, "OVER TIME MORE THAN 30 DAY IS REQUIRED")

            let market_id = generate_market_id()
            restrict_repeat_market(Call.caller,market_id)

            let market = {
                market_id     = market_id,
                owner         = Call.caller,
                content       = content,
                source_url    = source_url,
                answers       = answers,
                create_height = Chain.block_height,
                create_time   = Chain.timestamp,
                over_time     = Chain.timestamp + over_time,
                min_amount    = min_amount,
                total_amount  = 0,
                result        = -1,
                progress      = 0,
                market_type   = get_market_type()}

            switch(Map.lookup(Call.caller, state.markets))
                Some(account) => put(state {markets[Call.caller][market_id] = market})
                None => put(state {markets[Call.caller = {}][market_id] = market})

            market


    /**
     * 用户提交问题
     * - address: 发布的用户
     * - hash: 预测id
     * - int: 第几个答案
     */
    payable stateful entrypoint
        submit_answer : (address,hash,int) => bool
        submit_answer (market_address,market_id,answer_index) =
            let market = get_market(market_address,market_id)
            // require(market.over_time > Chain.timestamp,"MARKET TIME OUT")
            require(market.progress == 0,"MARKET PROGRESS IS NOT START")
            require(!is_user_markets_record(market_address,market_id),"USER MARKETS REPEAT")
            let answer = get_market_answer(market_address,market_id,answer_index)
            let new_answer  = {
                content = answer.content,
                count = answer.count + 1}
            let new_answers = List.replace_at(answer_index, new_answer, state.markets[market_address][market_id].answers)
            put(state {markets[market_address][market_id].answers = new_answers})

            put(state {markets[market_address][market_id].total_amount @n = n + Call.value})
            put(state {user_markets_record[market_address = {}][market_id  = {}][Call.caller] = answer_index})
            Chain.event(SubmitAnswer(market_address,market_id,answer_index))
            true


    /**
     * 更新预测到下一步，更改完后的状态用于获取场外结果，
     * 同时也插入等待中的预测，便于UI展示
     * - address: 发布的用户
     * - hash: 预测id
     */
    stateful entrypoint
        update_market_progress_to_wait : (address,hash)=>bool
        update_market_progress_to_wait (market_address,market_id) =
            let market = get_market(market_address,market_id)
            // require(market.over_time < Chain.timestamp,"MARKET TIME NOT OUT")
            require(market.progress == 0,"MARKET PROGRESS IS NOT START")
            // require(is_aggregator_user(),"AGGREGATOR ERROR")
            put(state {markets[market_address][market_id].progress = 1})
            put(state {oracle_market[market.market_id] = []})
            true

    /**
     * 更新预测到下一步，更改完后的状态用结束状态，领取奖金，
     * 同时也插入等待中的预测，便于UI展示
     * - address: 发布的用户
     * - hash: 预测id
     */
    stateful entrypoint
        update_market_progress_to_over : (address,hash)=>bool
        update_market_progress_to_over (market_address,market_id) =
            let market = get_market(market_address,market_id)
            // require(market.over_time < Chain.timestamp,"MARKET TIME NOT OUT")
            require(get_oracle_market_provide_count(market_id) >= state.orcele_trigger_count,"MARKET PROVIDE COUNT LOW")
            require(market.progress == 1,"MARKET PROGRESS IS NOT WAIT")
            // require(is_aggregator_user(),"AGGREGATOR ERROR")
            put(state {markets[market_address][market_id].progress = 2})
            true

    stateful entrypoint
        receive_reward : (address,hash)=>bool
        receive_reward (market_address,market_id) =
            Chain.event(ContractBalance(Contract.balance))
            let market = get_market(market_address,market_id)
            let reward_num = most_of(state.oracle_market[market_id])
            Chain.spend(Call.caller,market.total_amount/reward_num)
            Chain.event(ReceiveReward(Call.caller,reward_num,market.total_amount))
            Chain.event(ContractBalance(Contract.balance))

            true




    stateful entrypoint
        provide_answer : (address,hash,int) =>bool
        provide_answer (market_address,market_id,market_index) =
            let market = get_market(market_address,market_id)
            require(market_index < List.length(market.answers),"INDEX OUT ERROR")
            require(market_index >= 0, "INDEX OUT ERROR 0")
            require(is_aggregator_user(),"AGGREGATOR ERROR")
            require(market.progress == 1,"MARKET PROGRESS IS NOT WAIT")
            require(!is_oracle_market_record(market_id),"PROVIDE COUNT MARE")
            let provide_data = List.insert_at(0,market_index,state.oracle_market[market_id])
            put(state{oracle_market[market_id] = provide_data})
            put(state{oracle_market_record[market_id = {}][Call.caller] = market_index})
            put(state{oracle_market_count[market_id = 0] @ n = n + 1})
            true




    entrypoint
        get_oracle_market_provide_count : (hash) =>int
        get_oracle_market_provide_count (market_id) =
            state.oracle_market_count[market_id]




    /**
     * add调用者是否属于可发布聚合器账户列表中
     */
    stateful entrypoint
        add_aggregator_user : (address,string) => bool
        add_aggregator_user(account,name) =
            protocol_restrict()
            put(state {aggregator_user[account]= name})
            true


    /**
     * 获取具体预测
     * - market_address: 发布者的地址
     * - market_id: 发布者的具体预测
     */
    entrypoint
        get_market : (address,hash) => market
        get_market(market_address,market_id) =
            switch(Map.lookup(market_address, state.markets))
                Some(market_map) =>
                    switch(Map.lookup(market_id, market_map))
                        Some(market) =>  market
                        None => abort("DNT FIND THE MARKET")
                None => abort("DNT FIND THE MARKET")

    /**
     * 当前用户是否参与过预测
     */
    entrypoint
        is_user_markets_record : (address,hash) => bool
        is_user_markets_record(market_address,market_id) =
            switch(Map.lookup(market_address, state.user_markets_record))
                Some(market_map) =>
                    switch(Map.lookup(market_id, market_map))
                        Some(account) =>
                            switch(Map.lookup(Call.caller, account))
                                Some(account) =>  true
                                None => false
                        None => false
                None => false


    /**
     * 管理员是否投票过
     */
    entrypoint
        is_oracle_market_record : (hash) => bool
        is_oracle_market_record(market_id) =
            switch(Map.lookup(market_id, state.oracle_market_record))
                Some(market_record_user) =>
                    switch(Map.lookup(Call.caller, market_record_user))
                        Some(result) =>  true
                        None => false
                None => false




    /**
     * 检测是否有重复的预测
     * - market_address: 发布者的地址
     * - market_id: 发布者的具体预测
     */
    function
        restrict_repeat_market : (address,hash) => bool
        restrict_repeat_market(market_address,market_id) =
            switch(Map.lookup(market_address, state.markets))
                Some(market_map) =>
                    switch(Map.lookup(market_id, market_map))
                        Some(market) => abort("REPEAT MARKET")
                        None => true
                None => true
    /**
     * 当前调用者是否属于可发布聚合器账户列表中
     */
    function
        is_aggregator_user : () => bool
        is_aggregator_user() =
            switch(Map.lookup(Call.caller, state.aggregator_user))
                Some(user) => true
                None => false

    /**
     * 当前调用者是否属于可发布聚合器账户列表中
     */
    function
        get_market_type : () => int
        get_market_type() =
            switch(Map.lookup(Call.caller, state.aggregator_user))
                Some(user) => 0
                None => 1

    /**
     * 获取具体预测的答案
     * - market_address: 发布者的地址
     * - market_id: 发布者的具体预测
     * - answer_index: 答案中的第几个答案
     */
    function
        get_market_answer : (address,hash,int) => answer
        get_market_answer(market_address,market_id,answer_index) =
            switch(Map.lookup(market_address, state.markets))
                Some(market_map) =>
                    switch(Map.lookup(market_id, market_map))
                        Some(market) =>  List.get(answer_index, market.answers)
                        None => abort("DNT FIND THE ANSWER")
                None => abort("DNT FIND THE ANSWER")

    function
        protocol_restrict : () => unit
        protocol_restrict() =
            require(Call.origin == state.owner, "PROTOCOL_RESTRICTED")


    function
        generate_market_id : () => hash
        generate_market_id() =
            Crypto.sha256(String.concat(Address.to_str(Call.caller), Int.to_str(Chain.timestamp)))


    entrypoint
        get_state:()=>state
        get_state () =
            state






    
