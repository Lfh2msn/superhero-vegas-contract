@compiler >= 6

include "String.aes"
include "List.aes"

payable contract VegasMarketContact =


    datatype event =
        AddMarket(address, hash, int)
        | SubmitAnswer(address, hash, int)
        | ReceiveReward(address, int, int)
        | ContractBalance(int)


    /**
     *Contract status of Vegas
     * - markets: Store all user-initiated betting information
     * - user_markets_record: the history of bets that have participated
     * - oracle_market: a small oracle machine, the data provided by the super tube
     * - oracle_market_count: The number of times a prediction has been voted
     * - oracle_market_record: History after admin votes
     * - owner: the owner of the contract
     * - aggregator_user: the management account of the contract
     * - orcele_trigger_count: triggers the flag that waits for the result state to be updated to the ended state
     */
    record state = {
        //The predicted content, which user predicted the predicted content of the id (user, map(predicted id, predicted details))
        markets : map(address, map(hash, market)),
        //User voting record, which account publishes which prediction results of the user's vote
        user_markets_record : map(address, map(hash, map(address,int))),
        //The user's reward record, which account published which predicted the amount received by the user
        user_markets_receive_record : map(address, map(hash, map(address,int))),
        //A collection of predicted results
        oracle_market : map(hash, list(int)),
         //The number of times already predicted
        oracle_market_count : map(hash, int),
        //Records of administrator votes for later review
        oracle_market_record : map(hash, map(address, int)),
        // contract owner
        owner : address,
        //admin account
        aggregator_user : map(address, string),
        //config file
        config : config}

    record config = {
        // Trigger the number of times the prediction is completed
        oracle_trigger_count : int,
        // predict the lowest time limit
        market_min_time : int,
        // predict the highest time limit
        market_max_time : int}


    /**
     * Forecast details
     * - content: predicted content
     * - source_url: the predicted result query url address
     * - answers: predicted answer options
     * - create_height: the height created when publishing the forecast
     * - create_time: the time when the forecast was created
     * - min_amount: minimum bet amount
     * - total_amount: The total amount that has been wagered in the current forecast
     * - result: what is the answer for this prediction
     * - progress: current predicted progress (0) in-progress status, (1) waiting for result status, (2) completed status (999) void status, only available to the contract owner
     * - market_type: the type of the current forecast (0) aggregator mode, (1) private mode
     */
    record market = {
        //prophecy id sha256 (address + timestamp)
        market_id : hash,
        //announcer
        owner : address,
        //Content, used to display to the user
        content : string,
        //Get the address of the result for viewing
        source_url : string,
        // possible results
        answers : list(answer),
        // create height
        create_height : int,
        // created time
        create_time : int,
        // end time
        over_time : int,
        //Minimum bet amount
        min_amount : int,
        //How many bets on the current theme
        total_amount : int,
        // final result
        result : int,
        //What progress does it currently belong to
        progress : int,
        // type of prediction
        market_type : int}


    /**
     * Predicted answer
     * - content: the content of the predicted answer
     * - accounts: users who have bet
     */
    record answer = {
        //the content of the answer
        content : string,
        // number of times to choose an answer
        count : int}


    stateful entrypoint
        init : (config) => state
        init(config) =
            let owner = Call.caller
            { markets = {},
              user_markets_record = {},
              user_markets_receive_record = {},
              oracle_market = {},
              oracle_market_count = {},
              oracle_market_record = {},
              owner = Call.caller,
              aggregator_user = {},
              config=config}


    /**
     * Publish a forecast, only aggregator users can publish forecasts with status=(0)
     * - content: theme
     * - source_url: the address to get the result
     * - min_amount: minimum payment amount
     * - over_time: end timestamp, added from the current time
     * - answers: answer result
     */
    stateful entrypoint
        add_market : (string,string,int,int,list(answer)) => market
        add_market(content,source_url,min_amount,over_time,answers) =
            //The minimum end time should also be greater than the time in the configuration, such as 1 day greater than the current time and less than 30 days
            require(over_time >= state.config.market_min_time, "OVER TIME MORE THAN MIN REQUIRED")
            require(over_time =< state.config.market_max_time ,"OVER TIME MORE THAN MAX REQUIRED")
            //generate prediction id
            let market_id = generate_market_id()
            //Check if there is a duplicate id
            restrict_repeat_market(Call.caller,market_id)
            //The number of times to verify the answer is not equal to the default state throwing an error
            List.foreach(answers, (item) => require(item.count == 0 ,"ANSWER COUNT ERROR"))
            //build the theme
            let market = {
                market_id = market_id,
                owner = Call.caller,
                content = content,
                source_url = source_url,
                answers = answers,
                create_height = Chain.block_height,
                create_time = Chain.timestamp,
                over_time = Chain.timestamp + over_time,
                min_amount = min_amount,
                total_amount = 0,
                result = -1,
                progress = 0,
                market_type = get_market_type()}
            put(state {markets[Call.caller = {}][market_id] = market})
            market



    /**
     * User submitted questions
     * - address: the posted user
     * - hash: prediction id
     * - int: the first answer
     */
    payable stateful entrypoint
        submit_answer : (address,hash,int) => bool
        submit_answer(market_address,market_id,answer_index) =
            // get prediction
            let market = get_market(market_address,market_id)
            //If the predicted end time is less than the current time, prompt an error
            // require(market.over_time > Chain.timestamp,"MARKET TIME OUT")
            //If the current payment amount is less than the latest amount specified in the prediction, an error will be displayed
            require(Call.value == market.min_amount,"MARKET AMOUNT OUT")
            //If the current progress is not in the START state, prompt an error
            require(market.progress == 0,"MARKET PROGRESS IS NOT START")
            //If the current user has already participated in the question, prompt an error
            require(!is_user_markets_record(market_address,market_id),"USER MARKETS REPEAT")
            //Get the answer to submit
            let answer = get_market_answer(market_address,market_id,answer_index)
            //Construct a new answer object and add 1 to the number of bets
            let new_answer = {
                content = answer.content,
                count = answer.count + 1}
            // replace the old answer object with the new one
            let new_answers = List.replace_at(answer_index, new_answer, state.markets[market_address][market_id].answers)
            put(state {markets[market_address][market_id].answers = new_answers})
            //Save the total amount of the current bet
            put(state {markets[market_address][market_id].total_amount @n = n + Call.value})
            //Record the current prediction has been voted
            put(state {user_markets_record[market_address = {}][market_id = {}][Call.caller] = answer_index})
            Chain.event(SubmitAnswer(market_address,market_id,answer_index))
            true


    /**
     * Update the forecast to the next step, the changed state is used to obtain off-site results,
     * Also insert the waiting forecast for easy UI display
     * - address: the posted user
     * - hash: prediction id
     */
    stateful entrypoint
        update_market_progress_to_wait : (address,hash)=>bool
        update_market_progress_to_wait(market_address,market_id) =
            // get the current forecast
            let market = get_market(market_address,market_id)
            //If the predicted end time is not reached, prompt an error
            require(market.over_time < Chain.timestamp,"MARKET TIME NOT OUT")
            //If the state is not the result of the need for the oracle, prompt an error
            require(market.market_type == 1 ,"MARKET TYPE ERROR")
            //If the progress is not in the START state, prompt an error
            require(market.progress == 0,"MARKET PROGRESS IS NOT START")
            //require(is_aggregator_user(),"AGGREGATOR ERROR")
            //Change the prediction state to waiting for the result
            put(state {markets[market_address][market_id].progress = 1})
            put(state {oracle_market[market.market_id] = []})
            true



    /**
     * Collect data, provide results
     */
    stateful entrypoint
        provide_answer : (address,hash,int) =>bool
        provide_answer (market_address,market_id,market_index) =
            // get the current forecast
            let market = get_market(market_address,market_id)
            //If the provided result is greater than the total number of answers, prompt an error
            require(market_index < List.length(market.answers),"INDEX OUT ERROR")
            //If the provided result is negative, prompt an error
            require(market_index >= 0, "INDEX OUT ERROR 0")
            //If the state is not the result of the need for the oracle, prompt an error
            require(market.market_type == 1 ,"MARKET TYPE ERROR")
            //If the result is not provided by an authorized person, an error is displayed
            require(is_aggregator_user(), "AGGREGATOR ERROR")
            //If the current progress is not waiting for the result WAIT state, prompt an error
            require(market.progress == 1,"MARKET PROGRESS IS NOT WAIT")
            //If the current user has already provided a result for this prediction, prompt an error
            require(!is_oracle_market_record(market_id),"PROVIDE COUNT MARE")
            //insert the provided result data
            let provide_data = List.insert_at(0,market_index,state.oracle_market[market_id])
            // save the provided result
            put(state{oracle_market[market_id] = provide_data})
            //Save the result record of the prediction provided by the current user
            put(state{oracle_market_record[market_id = {}][Call.caller] = market_index})
            //Save the number of prediction results data
            put(state{oracle_market_count[market_id = 0] @ n = n + 1})
            true


   /**
     * Update the forecast to the next step, use the end state after the change, receive the bonus,
     * Also insert the waiting forecast for easy UI display
     * - address: the posted user
     * - hash: prediction id
     */
    stateful entrypoint
        update_market_progress_to_over : (address,hash)=>bool
        update_market_progress_to_over(market_address,market_id) =
            // get the current forecast
            let market = get_market(market_address,market_id)
            //If the predicted end time is not reached, prompt an error
            require(market.over_time < Chain.timestamp,"MARKET TIME NOT OUT")
            //If the state is not the result of the need for the oracle, prompt an error
            require(market.market_type == 1 ,"MARKET TYPE ERROR")
            //If the progress is not in WAIT state, prompt an error
            require(market.progress == 1,"MARKET PROGRESS IS NOT START")
            //If the data provided by the provider is not enough to meet the set standard, prompt an error
            require(get_oracle_market_provide_count(market_id) >= state.config.oracle_trigger_count,"MARKET PROVIDE COUNT LOW")
            // require(is_aggregator_user(),"AGGREGATOR ERROR")
            put(state {markets[market_address][market_id].progress = 2})
            // Calculate which has the most votes, then set the final result
            let reward_num = most_of(state.oracle_market[market_id])
            put(state {markets[market_address][market_id].result = reward_num})
            true




    /**
     * The private prediction is updated to the next step, the state after the change is the end state, and the bonus is received,
     * Also insert the waiting forecast for easy UI display
     * - address: the posted user
     * - hash: prediction id
     */
    stateful entrypoint
        private_update_market_progress_to_over : (address,hash,int)=>bool
        private_update_market_progress_to_over(market_address,market_id,result_index) =
            // get the current forecast
            let market = get_market(market_address,market_id)
            //If the method is not called by the publisher himself, an error is displayed
            require(market.owner == Call.caller,"MARKET TIME NOT OUT")
            //If the provided result is greater than the total number of answers, prompt an error
            require(result_index < List.length(market.answers),"INDEX OUT ERROR")
            //If the predicted end time is not reached, prompt an error
            require(market.over_time < Chain.timestamp,"MARKET TIME NOT OUT")
            //If the state is not the result of the need for the oracle, prompt an error
            require(market.market_type == 0 ,"MARKET TYPE ERROR")
            //If the progress is not in the START state, prompt an error
            require(market.progress == 0,"MARKET PROGRESS IS NOT START")
            //If the data provided by the provider is not enough to meet the set standard, prompt an error
            put(state {markets[market_address][market_id].progress = 2})
            // Calculate which has the most votes, then set the final result
            put(state {markets[market_address][market_id].result = result_index})
            true



    /**
     * Receive bonuses,
     */
    stateful entrypoint
        receive_reward : (address,hash)=>int
        receive_reward(market_address,market_id) =
            // get the current forecast
            let market = get_market(market_address,market_id)
            //If the progress is not OVER state, prompt an error
            require(market.progress == 2,"MARKET OVER IS NOT START")
            //If the current user has already participated in the question, prompt an error
            require(!is_user_markets_receive_record(market_address,market_id),"USER MARKETS REPEAT")
            //If the current user has not participated in the question, prompt an error
            require(is_user_markets_record(market_address,market_id),"USER RECORD MARKETS ERROR")
            //If the current user's vote and the final result are incorrect, prompt an error
            require(market.result == get_user_markets_record(market_address,market_id),"USER RECORD MARKETS RESULT ERROR")
            // //Get the correct answer
            let answer = get_market_answer(market_address,market_id,market.result)
            // //Calculate the amount that should be issued
            let amount = market.total_amount / answer.count
            // record that the current prediction has received the award
            put(state {user_markets_receive_record[market_address = {}][market_id = {}][Call.caller] = amount})
            //withdraw bonus
            Chain.spend(Call.caller, amount)
            Chain.event(ReceiveReward(Call.caller ,amount, market.total_amount))

            amount




    /**
     * Get predictions already several people have provided results
     */
    entrypoint
        get_oracle_market_provide_count : (hash) =>int
        get_oracle_market_provide_count(market_id) =
            state.oracle_market_count[market_id]




    /**
     * Whether the add caller belongs to the list of publishable aggregator accounts
     */
    stateful entrypoint
        add_aggregator_user : (address,string) => bool
        add_aggregator_user(account,name) =
            protocol_restrict()
            put(state {aggregator_user[account]= name})
            true


    /**
     * Get specific forecasts
     * - market_address: the address of the publisher
     * - market_id: Publisher's specific forecast
     */
    entrypoint
        get_market : (address,hash) => market
        get_market(market_address,market_id) =
            switch(Map.lookup(market_address, state.markets))
                Some(market_map) =>
                    switch(Map.lookup(market_id, market_map))
                        Some(market) => market
                        None => abort("DNT FIND THE MARKET")
                None => abort("DNT FIND THE MARKET")


    /**
     * Whether the current user has received a bonus
     */
    entrypoint
        is_user_markets_receive_record : (address,hash) => bool
        is_user_markets_receive_record(market_address,market_id) =
            switch(Map.lookup(market_address, state.user_markets_receive_record))
                Some(market_map) =>
                    switch(Map.lookup(market_id, market_map))
                        Some(account) =>
                            switch(Map.lookup(Call.caller, account))
                                Some(account) => true
                                None => false
                        None => false
                None => false

    /**
     * Whether the current user has participated in the prediction
     */
    entrypoint
        is_user_markets_record : (address,hash) => bool
        is_user_markets_record(market_address,market_id) =
            switch(Map.lookup(market_address, state.user_markets_record))
                Some(market_map) =>
                    switch(Map.lookup(market_id, market_map))
                        Some(account) =>
                            switch(Map.lookup(Call.caller, account))
                                Some(account) => true
                                None => false
                        None => false
                None => false


    /**
     * Whether the current user has participated in the prediction
     */
    entrypoint
        get_user_markets_record : (address,hash) => int
        get_user_markets_record(market_address,market_id) =
            switch(Map.lookup(market_address, state.user_markets_record))
                Some(market_map) =>
                    switch(Map.lookup(market_id, market_map))
                        Some(account) =>
                            switch(Map.lookup(Call.caller, account))
                                Some(result) => result
                                None => -1
                        None => -1
                None => -1


    /**
     * Has the administrator voted
     */
    entrypoint
        is_oracle_market_record : (hash) => bool
        is_oracle_market_record(market_id) =
            switch(Map.lookup(market_id, state.oracle_market_record))
                Some(market_record_user) =>
                    switch(Map.lookup(Call.caller, market_record_user))
                        Some(result) => true
                        None => false
                None => false




    /**
     * Check for duplicate predictions
     * - market_address: the address of the publisher
     * - market_id: Publisher's specific forecast
     */
    function
        restrict_repeat_market : (address,hash) => bool
        restrict_repeat_market(market_address,market_id) =
            switch(Map.lookup(market_address, state.markets))
                Some(market_map) =>
                    switch(Map.lookup(market_id, market_map))
                        Some(market) => abort("REPEAT MARKET")
                        None => true
                None => true
    /**
     * Whether the current caller belongs to the list of publishable aggregator accounts
     */
    function
        is_aggregator_user : () => bool
        is_aggregator_user() =
            switch(Map.lookup(Call.caller, state.aggregator_user))
                Some(user) => true
                None => false

    /**
     * Whether the current caller belongs to the list of publishable aggregator accounts
     */
    function
        get_market_type : () => int
        get_market_type() =
            if(state.owner == Call.caller) 1
            else 0

    /**
     * Get answers to specific predictions
     * - market_address: the address of the publisher
     * - market_id: Publisher's specific forecast
     * - answer_index: the number of answers in the answer
     */
    function
        get_market_answer : (address,hash,int) => answer
        get_market_answer(market_address,market_id,answer_index) =
            switch(Map.lookup(market_address, state.markets))
                Some(market_map) =>
                    switch(Map.lookup(market_id, market_map))
                        Some(market) => List.get(answer_index, market.answers)
                        None => abort("DNT FIND THE ANSWER")
                None => abort("DNT FIND THE ANSWER")
    /**
     * Whether the current caller is the contract owner
     */
    function
        protocol_restrict : () => unit
        protocol_restrict() =
            require(Call.caller == state.owner, "PROTOCOL_RESTRICTED")

    /**
     * Generate prediction ID
     */
    function
        generate_market_id : () => hash
        generate_market_id() =
            Crypto.sha256(String.concat(Address.to_str(Call.caller), Int.to_str(Chain.timestamp)))


    // Get the result with the most votes
    entrypoint most_of((x :: xs) : list('a )) : 'a =
        most_of_(x, {[x] = 1}, xs)

    function most_of_(most : 'a, counts : map('a, int), xs : list('a)) =
        switch(xs)
            [] => (most)
            (x :: xs) =>
                let counts' = counts{ [x = 0] @ n = n + 1 }
                if (counts'[x] >= counts'[most])
                    most_of_(x, counts', xs)
                else
                    most_of_(most, counts', xs)

    entrypoint
        get_state:()=>state
        get_state() =
            state
